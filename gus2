#!/usr/bin/env python3

from argparse import ArgumentParser, ArgumentTypeError
import re
import time
import hashlib
import os
import json
import pystache
import docutils.core

parser = ArgumentParser(prog="gus", description="Generate static sites from textile and mustache files.")
def src_dest_argtype(string):
	match = re.match("(?P<src>[^:]+):(?P<dest>[^:]+)", string)
	if match is None:
		raise ArgumentTypeError("gus src_dir:dest_dir")
	return match.groupdict()

parser.add_argument("-w", "--watch", action="store_true", help="Watch src directory for changes.")
parser.add_argument("src_dest", metavar="src_dir:dest_dir", type=src_dest_argtype,
	help="The source and generated site are set using a colon. For example, gus src:public")

args = parser.parse_args()

class Node:
    def __init__(self):
        self.is_dirty = None

    def dirty(self):
        self.is_dirty = True
        for child in self.children().items():
            child.dirty()
    def render_in_layout(self, ctx):
        if self.parent:
            with open(self.parent.layout.path, 'r') as layout:
                return {'body': pystache.render(layout, ctx)}
        else:
            return ctx['body']
    def print(self, indent=0):
        pre = ((indent * 2) * ' ')
        post = ''
        if self.is_dirty:
            post='*'
        print(pre + self.name + post)
        for name,child in self.children().items():
            child.print(indent+1)
    def render(self):
        raise Exception('This method should be overridden')

class RenderedDoc:
    def __init__(self, body, authors, pub_date):
        self.body = body
        self.authors = authors
        self.pub_date = pub_date

class RstRenderer:
    @staticmethod
    def render(cntnt):
        # dict_keys(['subtitle', 'version', 'encoding', 
        #            'html_prolog', 'header', 'meta', 
        #            'html_title', 'title', 'stylesheet', 
        #            'html_subtitle', 'html_body', 'body', 
        #            'head', 'body_suffix', 'fragment', 
        #            'docinfo', 'html_head', 'head_prefix', 
        #            'body_prefix', 'footer', 'body_pre_docinfo', 
        #            'whole'])
        doc_parts = docutils.core.publish_parts(cntnt, writer_name='html')
        doc_tree = docutils.core.publish_doctree(cntnt)
        authors = []
        pub_date = None
        for node in doc_tree.traverse():
            if node.tagname == 'author':
                authors.append(node.astext())
            elif node.tagname == 'date':
                pub_date = node.astext()

        return RenderedDoc(body = doc_parts['body'], 
                           authors = authors, 
                           pub_date = pub_date)


class File(Node):
    hasher = hashlib.sha256
    def __init__(self):
        super().__init__()
        self.name = None
        self.path = None
        self.mtime = None
        self.size = None
        self.hash = None
        self.parent = None

    def children(self):
        return dict()

    def render(self):
        if self.path[-3:] == 'rst':
            rd = RstRenderer.render(self.file_content)
            return self.render_in_layout(rd.__dict__)

    @staticmethod
    def from_path(path, parent):
        self = File()
        self.path = path
        self.parent = parent
        self.name = os.path.basename(path)
        fstats = os.stat(path)
        self.mtime = fstats.st_mtime
        self.size = fstats.st_size
        with open(path, 'rb') as f:
            self.file_content = f.read()
            self.hash = self.hasher(self.file_content).hexdigest()
        return self

class Section(Node):
    def __init__(self):
        super().__init__()
        self.indices = None
        self.layout = None
        self.template = None
        self.subsections = {}
        self.pages = {}
        self.name = None
        self.path = None
        self.parent = None
    def children(self):
        return dict(list(self.subsections.items()) + list(self.pages.items()))

    @staticmethod
    def from_path(path, parent = None):
        self = Section()
        self.name = os.path.basename(path)
        self.path = path
        self.parent = parent
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            if os.path.isfile(item_path):
                if item == 'layout.mustache':
                   self.layout = File.from_path(item_path, parent = self)
                elif item == 'template.mustache':
                    self.template = File.from_path(item_path, parent = self)
                elif item == 'indices.yml':
                    self.indices = File.from_path(item_path, parent = self)
                else:
                    self.pages[item] = File.from_path(item_path, parent = self)
            else:
                self.subsections[item] = Section.from_path(item_path, parent = self)
        if not self.layout:
            raise Exception('Section must have a layout.mustache')
        if not self.template:
            raise Exception('Section must have a template.mustache')
        if not self.indices:
            raise Exception('Section must have a indices.yml')
        return self

#print(json.dumps(Section.from_path(args.src_dest['src'] + '/src'), default=lambda x : x.__dict__))

s = Section.from_path(args.src_dest['src'] + '/src')
s.print()

s.subsections['posts'].pages['post-1.rst'].render()
