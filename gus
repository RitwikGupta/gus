#!/usr/bin/env python

import os
import shutil
import copy
import pystache
from textile import textile
import yaml
from argparse import ArgumentParser, ArgumentTypeError
import re

parser = ArgumentParser(prog="gus", description="Generate static sites from textile and mustache files.")
def src_dest_argtype(string):
	match = re.match("(?P<src>[^:]+):(?P<dest>[^:]+)", string)
	if match is None:
		raise ArgumentTypeError("gus [--match] src_dir:dest_dir")
	return match.groupdict()

parser.add_argument("-w", "--watch", action="store_true", help="Watch src directory for changes.")
parser.add_argument("src_dest", metavar="src_dir:dest_dir", type=src_dest_argtype,
	help="The source and generated site are set using a colon. For example, gus src:public")

args = parser.parse_args()

class Gus:
	def __init__(self, site_dir, dest_dir):
		assert os.path.isdir(site_dir), "%s must be a dir" % site_dir
		
		properties_file = os.path.join(site_dir, "properties.yml")
		assert os.path.isfile(properties_file), "%s must be a file" % properties_file
		with open(properties_file, 'r') as f:
			self.properties = yaml.load(f)
		
		pages_path      = os.path.join(site_dir, "pages")
		assert os.path.isdir(pages_path), "%s must be a dir" % pages_path
		self.pages_path = pages_path
		
		assets_path     = os.path.join(site_dir, "assets")
		assert os.path.isdir(assets_path), "%s must be a dir" % assets_path
		self.assets_path = assets_path
		
		rendered_path   = dest_dir
		assert os.path.isdir(rendered_path), "%s must be a dir" % rendered_path
		assert os.access(rendered_path, os.W_OK), "%s must be writable" % rendered_path
		# Perhaps render in a tmpdir first, then change links. This is too destructive too early.
		for dirname, dirnames, filenames in os.walk(rendered_path):
			for subdirname in dirnames:
				shutil.rmtree(os.path.join(rendered_path, subdirname))
			for filename in filenames:
				os.unlink(os.path.join(rendered_path, filename))
		self.rendered_path = rendered_path
		
		posts_path      = os.path.join(pages_path, "posts")
		assert os.path.isdir(posts_path), "%s must be a dir" % posts_path
		self.posts_path = posts_path
		
		top_level_path         = os.path.join(pages_path, "top-level")
		assert os.path.isdir(top_level_path), "%s must be a dir" % top_level_path
		self.top_level_path = top_level_path
		
		templates_path  = os.path.join(site_dir, "templates")
		assert os.path.isdir(templates_path), "%s must be a dir" % templates_path
		self.templates_path = templates_path

		layout_template = os.path.join(templates_path, "layout.mustache")
		assert os.path.isfile(layout_template), "%s must be a file" % layout_template
		with open(layout_template, 'r') as f:
			self.layout_template = f.read()
		
		posts_template  = os.path.join(templates_path, "post.mustache")
		assert os.path.isfile(posts_template), "%s must be a file" % posts_template
		with open(posts_template, 'r') as f:
			self.posts_template = f.read()
		
		top_level_template     = os.path.join(templates_path, "top-level.mustache")
		assert os.path.isfile(top_level_template), "%s must be a file" % top_level_template
		with open(top_level_template, 'r') as f:
			self.top_level_template = f.read()

	def render_file(self, file_name, page_template):
		post_raw = None
		with open(file_name) as f:
			post_raw = f.read()
		post_rendered = textile(re.sub('^\%.*$', '', post_raw, 0, re.MULTILINE))
		meta = re.finditer( '^%(\S*) (.*)$', post_raw, re.MULTILINE)
		props = copy.deepcopy(self.properties)
		props['page'] = {}
		for match in meta:
			name = match.group(1)
			val  = match.group(2)
			if name == 'tags':
				val = val.split(' ')
			props['page'][name] = val
			props[name] = val
		props['body'] = post_rendered
		props['body'] = pystache.render(page_template, props)
		props['body'] = pystache.render(props['body'], props)
		page_layout = pystache.render(self.layout_template, props)
		return page_layout
	
	def render_pages(self, pages_dir, page_template, dest_dir, base_dir = None):
		print 'pages', pages_dir
		print 'page_template', page_template
		print 'dest_dir', dest_dir
		print 'base_dir', base_dir
		if base_dir is None:
			base_dir = pages_dir
		for dirname, dirnames, filenames in os.walk(pages_dir):
			for subdirname in dirnames:
				self.render_posts(os.path.join(pages_dir, subdirname), page_template, dest_file, base_dir)
			for filename in filenames:
				src_file = os.path.join(pages_dir, filename)
				rel_file = re.sub(base_dir + os.path.sep, '', src_file)
				rel_file = re.sub('\.textile', '', rel_file)
				dest_file_dir = os.path.join(self.rendered_path, dest_dir)
				dest_file = os.path.join(dest_file_dir, rel_file + ".html")
				rendered_page = self.render_file(src_file, page_template)
				if not os.path.isdir(dest_file_dir):
					os.makedirs(dest_file_dir)
				with open(dest_file, 'w+') as f:
					f.write(rendered_page);
	def render_posts(self):
		self.render_pages(self.posts_path, self.posts_template, 'posts')
	def render_top_level(self):
		self.render_pages(self.top_level_path, self.top_level_template, '')
	def copy_assets(self):
		for dirname, dirnames, filenames in os.walk(self.assets_path):
			for name in dirnames:
				rendered_name = os.path.join(self.rendered_path, name)
				asset_name    = os.path.join(self.assets_path, name)
				shutil.copytree(asset_name, rendered_name)
			for name in filenames:
				rendered_name = os.path.join(self.rendered_path, name)
				asset_name    = os.path.join(self.assets_path, name)
				shutil.copy(asset_name, rendered_name)
	def render_site(self):
		self.render_posts()
		self.render_top_level()
		self.copy_assets()

gus = Gus(args.src_dest['src'], args.src_dest['dest'])
gus.render_site()
